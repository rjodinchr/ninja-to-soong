// Copyright 2024 ninja-to-soong authors
// SPDX-License-Identifier: Apache-2.0;

use crate::ninja_target::*;
use crate::project::*;
use crate::soong_module::*;
use crate::soong_module_generator::*;
use crate::utils::*;

#[derive(Default)]
pub struct SoongPackage {
    modules: Vec<SoongModule>,
    internals: SoongModuleGeneratorInternals,
}

impl SoongPackage {
    pub fn new(
        default_visibility: &str,
        license_module_name: &str,
        license_kinds: &[&str],
        license_text: &[&str],
    ) -> Self {
        Self::default()
            .add_module(
                SoongModule::new("package")
                    .add_prop(
                        "default_visibility",
                        SoongProp::VecStr(vec![String::from(default_visibility)]),
                    )
                    .add_prop(
                        "default_applicable_licenses",
                        SoongProp::VecStr(vec![String::from(license_module_name)]),
                    ),
            )
            .add_module(
                SoongModule::new("license")
                    .add_prop("name", SoongProp::Str(String::from(license_module_name)))
                    .add_prop(
                        "visibility",
                        SoongProp::VecStr(vec![String::from(":__subpackages__")]),
                    )
                    .add_prop(
                        "license_kinds",
                        SoongProp::VecStr(
                            license_kinds
                                .into_iter()
                                .map(|kind| String::from(*kind))
                                .collect(),
                        ),
                    )
                    .add_prop(
                        "license_text",
                        SoongProp::VecStr(
                            license_text
                                .into_iter()
                                .map(|text| String::from(*text))
                                .collect(),
                        ),
                    ),
            )
    }

    pub fn add_module(mut self, module: SoongModule) -> SoongPackage {
        self.modules.push(module);
        self
    }

    pub fn filter_local_include_dirs(&mut self, prefix: &str, files: &Vec<PathBuf>) {
        let mut set = std::collections::HashSet::new();
        for file in files {
            let mut path = file.clone();
            while let Some(parent) = path.parent() {
                path = PathBuf::from(parent);
                set.insert(path.clone());
            }
        }
        for module in &mut self.modules {
            module.update_prop("local_include_dirs", |prop| match prop {
                SoongProp::VecStr(dirs) => SoongProp::VecStr(
                    dirs.into_iter()
                        .filter(|dir| {
                            if let Ok(strip) = Path::new(&dir).strip_prefix(prefix) {
                                if !set.contains(strip) {
                                    return false;
                                }
                            }
                            return true;
                        })
                        .collect(),
                ),
                _ => prop,
            });
        }
    }

    pub fn print(self) -> String {
        let mut package = String::from(
            "//
// This file has been auto-generated by ninja-to-soong
//
// ******************************
// *** DO NOT MODIFY MANUALLY ***
// ******************************
//
// https://github.com/rjodinchr/ninja-to-soong
//
",
        );
        for module in self.modules {
            package += &module.print();
        }
        package
    }

    pub fn get_gen_deps(&self) -> Vec<PathBuf> {
        let mut gen_deps = self.internals.deps.clone();
        gen_deps.sort_unstable();
        gen_deps.dedup();
        gen_deps
    }

    pub fn get_gen_libs(&self) -> Vec<PathBuf> {
        let mut gen_libs = self.internals.libs.clone();
        gen_libs.sort_unstable();
        gen_libs.dedup();
        gen_libs
    }

    pub fn generate<T>(
        mut self,
        targets_to_gen: NinjaTargetsToGenMap,
        targets: Vec<T>,
        src_path: &Path,
        ndk_path: &Path,
        build_path: &Path,
        gen_build_prefix: Option<&str>,
        project: &dyn Project,
    ) -> Result<SoongPackage, String>
    where
        T: NinjaTarget,
    {
        let targets_map = NinjaTargetsMap::new(&targets);
        let mut gen = SoongModuleGenerator::new(
            src_path,
            ndk_path,
            build_path,
            gen_build_prefix,
            &targets_map,
            &targets_to_gen,
            project,
        );
        targets_map.traverse_from(targets_to_gen.get_targets(), |target| {
            let target_name = target.get_name();
            debug_project!("filter_target({target_name:#?})");
            if !project.filter_target(&target_name) {
                return Ok(false);
            }
            self.modules.push(match target.get_rule()? {
                NinjaRule::Binary => gen.generate_object("cc_binary", target)?,
                NinjaRule::SharedLibrary => gen.generate_object("cc_library_shared", target)?,
                NinjaRule::StaticLibrary => gen.generate_object("cc_library_static", target)?,
                NinjaRule::CustomCommand(rule_cmd) => gen.generate_custom_command(target, rule_cmd),
                NinjaRule::None => return Ok(true),
            });
            Ok(true)
        })?;
        self.internals = gen.delete();

        Ok(self)
    }
}
