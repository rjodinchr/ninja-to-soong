// Copyright 2024 ninja-to-soong authors
// SPDX-License-Identifier: Apache-2.0

use std::collections::{HashMap, HashSet};

use crate::ninja_target::*;
use crate::project::Project;
use crate::soong_module::*;
use crate::utils::*;

pub struct SoongPackage<'a> {
    modules: Vec<SoongModule>,
    gen_deps: HashSet<PathBuf>,
    gen_libs: HashSet<PathBuf>,
    src_path: &'a Path,
    ndk_path: &'a Path,
    build_path: &'a Path,
}

impl<'a> SoongPackage<'a> {
    pub fn new(
        src_path: &'a Path,
        ndk_path: &'a Path,
        build_path: &'a Path,
        default_visibility: &str,
        license_module_name: &str,
        license_kinds: Vec<&str>,
        license_text: Vec<&str>,
    ) -> Self {
        let mut package = Self {
            modules: Vec::new(),
            gen_deps: HashSet::new(),
            gen_libs: HashSet::new(),
            src_path,
            ndk_path,
            build_path,
        };
        let mut package_module = SoongModule::new("package");
        package_module.add_prop(
            "default_visibility",
            SoongProp::VecStr(vec![String::from(default_visibility)]),
        );
        package_module.add_prop(
            "default_applicable_licenses",
            SoongProp::VecStr(vec![String::from(license_module_name)]),
        );
        package.add_module(package_module);

        let mut license_module = SoongModule::new("license");
        license_module.add_prop("name", SoongProp::Str(String::from(license_module_name)));
        license_module.add_prop(
            "visibility",
            SoongProp::VecStr(vec![String::from(":__subpackages__")]),
        );
        license_module.add_prop(
            "license_kinds",
            SoongProp::VecStr(
                license_kinds
                    .into_iter()
                    .map(|kind| String::from(kind))
                    .collect(),
            ),
        );
        license_module.add_prop(
            "license_text",
            SoongProp::VecStr(
                license_text
                    .into_iter()
                    .map(|text| String::from(text))
                    .collect(),
            ),
        );
        package.add_module(license_module);

        package
    }

    pub fn add_module(&mut self, module: SoongModule) {
        self.modules.push(module);
    }

    pub fn filter_local_include_dirs(&mut self, prefix: &str, files: &Vec<PathBuf>) {
        let mut set = HashSet::new();
        for file in files {
            let mut path = file.clone();
            while let Some(parent) = path.parent() {
                path = PathBuf::from(parent);
                set.insert(path.clone());
            }
        }
        for module in &mut self.modules {
            module.update_prop("local_include_dirs", |prop| match prop {
                SoongProp::VecStr(dirs) => SoongProp::VecStr(
                    dirs.into_iter()
                        .filter(|dir| {
                            if let Ok(strip) = Path::new(&dir).strip_prefix(prefix) {
                                if !set.contains(strip) {
                                    return false;
                                }
                            }
                            return true;
                        })
                        .collect(),
                ),
                _ => prop,
            });
        }
    }

    pub fn print(self) -> String {
        let mut package = String::from(
            "//
// This file has been auto-generated by ninja-to-soong
//
// ******************************
// *** DO NOT MODIFY MANUALLY ***
// ******************************
//
// https://github.com/rjodinchr/ninja-to-soong
//
",
        );
        for module in self.modules {
            package += &module.print();
        }
        package
    }

    pub fn get_gen_deps(&self) -> Vec<PathBuf> {
        Vec::from_iter(self.gen_deps.to_owned())
    }

    pub fn get_gen_libs(&self) -> Vec<PathBuf> {
        Vec::from_iter(self.gen_libs.to_owned())
    }

    fn get_defines(&self, defines: Vec<String>, project: &dyn Project) -> Vec<String> {
        defines
            .iter()
            .filter(|def| project.filter_define(def))
            .map(|def| format!("-D{0}", project.get_define(def)))
            .collect()
    }

    fn get_cflags(&self, cflags: Vec<String>, project: &dyn Project) -> Vec<String> {
        cflags
            .into_iter()
            .filter(|cflag| project.filter_cflag(cflag))
            .collect()
    }

    fn get_includes(&self, includes: Vec<PathBuf>, project: &dyn Project) -> Vec<String> {
        includes
            .iter()
            .filter(|include| project.filter_include(include))
            .map(|inc| path_to_string(strip_prefix(project.get_include(&inc), self.src_path)))
            .collect()
    }

    fn get_libs(&mut self, libs: Vec<PathBuf>, project: &dyn Project) -> Vec<String> {
        libs.iter()
            .filter(|lib| project.filter_lib(&path_to_string(lib)))
            .map(|lib| {
                if lib.starts_with(&self.ndk_path) {
                    file_stem(lib)
                } else {
                    self.gen_libs.insert(lib.clone());
                    let lib_id = path_to_id(project.get_lib(&lib));
                    project.get_target_name(&lib_id)
                }
            })
            .collect()
    }

    fn generate_object<T>(
        &mut self,
        name: &str,
        target: &T,
        targets_map: &NinjaTargetsMap<T>,
        project: &dyn Project,
    ) -> Result<SoongModule, String>
    where
        T: NinjaTarget,
    {
        let target_name = target.get_name(project.get_name());
        let mut cflags = HashSet::new();
        let mut includes = HashSet::new();
        let mut sources = HashSet::new();
        let mut static_libs = HashSet::new();
        let mut shared_libs = HashSet::new();
        let mut gen_deps = Vec::new();
        for input in target.get_inputs() {
            let Some(input_target) = targets_map.get(input) else {
                return error!("unsupported input for library: {input:#?}");
            };

            sources.extend(
                input_target
                    .get_sources(self.build_path)?
                    .iter()
                    .filter(|source| project.filter_source(source))
                    .map(|source| {
                        if source.starts_with(self.build_path) {
                            gen_deps.push(strip_prefix(&source, self.build_path));
                        }
                        path_to_string(strip_prefix(project.get_source(&source), self.src_path))
                    }),
            );

            let (static_libraries, shared_libraries) = input_target.get_link_libraries()?;
            static_libs.extend(self.get_libs(static_libraries, project));
            shared_libs.extend(self.get_libs(shared_libraries, project));

            includes.extend(self.get_includes(input_target.get_includes(self.build_path), project));
            cflags.extend(self.get_defines(input_target.get_defines(), project));
            cflags.extend(self.get_cflags(input_target.get_cflags(), project));
        }

        includes.extend(self.get_includes(target.get_includes(self.build_path), project));
        cflags.extend(self.get_defines(target.get_defines(), project));
        cflags.extend(self.get_cflags(target.get_cflags(), project));
        cflags.extend(project.get_target_cflags(&target_name));

        let (version_script, link_flags) = target.get_link_flags();
        let link_flags = link_flags
            .into_iter()
            .filter(|flag| project.filter_link_flag(flag))
            .collect::<Vec<String>>();
        let (static_libraries, shared_libraries) = target.get_link_libraries()?;
        static_libs.extend(self.get_libs(static_libraries, project));
        shared_libs.extend(self.get_libs(shared_libraries, project));
        shared_libs.extend(project.get_target_shared_libs(&target_name));

        let gen_headers = targets_map
            .traverse_from(
                target.get_outputs().clone(),
                HashSet::new(),
                |gen_headers, rule, target| match rule {
                    NinjaRule::CustomCommand => {
                        if target.get_cmd()?.is_none() {
                            return Ok(());
                        }
                        gen_headers.extend(target.get_outputs().clone());
                        return Ok(());
                    }
                    _ => return Ok(()),
                },
                |_target_name| true,
            )?
            .iter()
            .filter(|header| {
                if !project.filter_gen_header(header) {
                    gen_deps.push(PathBuf::from(header));
                    false
                } else {
                    true
                }
            })
            .map(|header| {
                targets_map
                    .get(&header)
                    .unwrap()
                    .get_name(project.get_name())
            })
            .collect::<HashSet<String>>();

        self.gen_deps.extend(gen_deps);

        let module_name = project.get_target_name(&target_name);
        static_libs.remove(&module_name);
        shared_libs.remove(&module_name);

        let mut module = SoongModule::new(name);
        module.add_prop("name", SoongProp::Str(module_name));
        if let Some(stem) = project.get_target_stem(&target_name) {
            module.add_prop("stem", SoongProp::Str(stem));
        }
        if let Some(vs) = version_script {
            module.add_prop(
                "version_script",
                SoongProp::Str(path_to_string(strip_prefix(vs, &self.src_path))),
            );
        }
        module.add_prop("srcs", SoongProp::VecStr(Vec::from_iter(sources)));
        module.add_prop("cflags", SoongProp::VecStr(Vec::from_iter(cflags)));
        module.add_prop("ldflags", SoongProp::VecStr(link_flags));
        module.add_prop(
            "shared_libs",
            SoongProp::VecStr(Vec::from_iter(shared_libs)),
        );
        module.add_prop(
            "static_libs",
            SoongProp::VecStr(Vec::from_iter(static_libs)),
        );
        module.add_prop(
            "local_include_dirs",
            SoongProp::VecStr(Vec::from_iter(includes)),
        );
        module.add_prop(
            "generated_headers",
            SoongProp::VecStr(Vec::from_iter(gen_headers)),
        );

        Ok(project.get_target_object_module(&target_name, module))
    }

    fn get_cmd(
        &self,
        rule_cmd: NinjaRuleCmd,
        inputs: HashSet<PathBuf>,
        outputs: &Vec<PathBuf>,
        deps: HashMap<PathBuf, String>,
        project: &dyn Project,
    ) -> String {
        let mut cmd = rule_cmd.command;
        while let Some(index) = cmd.find("python") {
            let begin = std::str::from_utf8(&cmd.as_bytes()[0..index])
                .unwrap()
                .rfind(" ")
                .unwrap_or_default();
            cmd = match std::str::from_utf8(&cmd.as_bytes()[index..])
                .unwrap()
                .find(" ")
            {
                Some(end) => cmd.replace(
                    std::str::from_utf8(&cmd.as_bytes()[begin..index + end + 1]).unwrap(),
                    "",
                ),
                None => cmd.replace(std::str::from_utf8(&cmd.as_bytes()[begin..]).unwrap(), ""),
            };
        }
        cmd = cmd.replace(&path_to_string_with_separator(self.build_path), "");
        for output in outputs {
            let marker = "<output>";
            let replace_output = path_to_string(project.get_cmd_output(output));
            cmd = cmd
                .replace(&path_to_string(output), marker)
                .replace(&format!(" {0}", file_name(output)), &format!(" {marker}"))
                .replace(marker, &format!("$(location {replace_output})"));
        }
        for input in inputs {
            let replace_input = path_to_string(strip_prefix(
                canonicalize_path(&input, self.build_path),
                self.src_path,
            ));
            cmd = cmd.replace(
                &path_to_string(&input),
                &format!("$(location {replace_input})"),
            )
        }
        for (dep, dep_target_name) in deps {
            cmd = cmd.replace(
                &path_to_string(&dep),
                &format!("$(location :{dep_target_name})"),
            )
        }
        if let Some((rsp_file, rsp_content)) = rule_cmd.rsp_info {
            let rsp = format!("$(genDir)/{rsp_file}");
            cmd = format!(
                "echo \\\"{0}\\\" > {rsp} && {cmd}",
                rsp_content
                    .split(" ")
                    .filter(|file| !file.is_empty())
                    .map(|file| {
                        let file_path = path_to_string(strip_prefix(
                            canonicalize_path(file, self.build_path),
                            self.src_path,
                        ));
                        format!("$(location {file_path})",)
                    })
                    .collect::<Vec<String>>()
                    .join(" ")
            )
            .replace("${rspfile}", &rsp);
        }
        cmd
    }

    fn get_cmd_inputs(
        &self,
        inputs: &Vec<PathBuf>,
        deps: &mut HashMap<PathBuf, String>,
        project: &dyn Project,
    ) -> Vec<PathBuf> {
        inputs
            .iter()
            .filter(|input| {
                for (prefix, dep) in project.get_deps_info() {
                    if input.starts_with(&prefix) {
                        deps.insert(
                            PathBuf::from(input),
                            dep_name(&input, &prefix, dep.str(), self.build_path),
                        );
                        return false;
                    }
                }
                if !canonicalize_path(&input, self.build_path).starts_with(self.src_path) {
                    deps.insert(
                        PathBuf::from(input),
                        dep_name(
                            &input,
                            self.build_path,
                            &project.get_name(),
                            self.build_path,
                        ),
                    );
                    return false;
                }
                true
            })
            .map(|input| PathBuf::from(input))
            .collect()
    }

    fn generate_custom_command<T>(
        &mut self,
        target: &T,
        rule_cmd: NinjaRuleCmd,
        project: &dyn Project,
    ) -> Result<SoongModule, String>
    where
        T: NinjaTarget,
    {
        let mut inputs = HashSet::new();
        let mut deps = HashMap::new();
        inputs.extend(self.get_cmd_inputs(target.get_inputs(), &mut deps, project));
        inputs.extend(self.get_cmd_inputs(target.get_implicit_deps(), &mut deps, project));
        let mut sources = inputs
            .clone()
            .iter()
            .map(|input| {
                path_to_string(strip_prefix(
                    canonicalize_path(input, self.build_path),
                    self.src_path,
                ))
            })
            .collect::<HashSet<String>>();
        for (dep, dep_target_name) in &deps {
            sources.insert(format!(":{dep_target_name}"));
            self.gen_deps.insert(dep.clone());
        }
        let target_outputs = target.get_outputs();
        let cmd = self.get_cmd(rule_cmd, inputs, target_outputs, deps, project);
        let outputs = target_outputs
            .iter()
            .map(|output| path_to_string(project.get_cmd_output(output)))
            .collect::<HashSet<String>>();

        let mut module = SoongModule::new("cc_genrule");
        module.add_prop("name", SoongProp::Str(target.get_name(project.get_name())));
        module.add_prop("cmd", SoongProp::Str(cmd));
        module.add_prop("srcs", SoongProp::VecStr(Vec::from_iter(sources)));
        module.add_prop("out", SoongProp::VecStr(Vec::from_iter(outputs)));

        Ok(module)
    }

    pub fn generate<T>(
        &mut self,
        targets_to_generate: Vec<PathBuf>,
        targets: Vec<T>,
        project: &dyn Project,
    ) -> Result<(), String>
    where
        T: NinjaTarget,
    {
        let targets_map = NinjaTargetsMap::new(&targets);
        targets_map.traverse_from(
            targets_to_generate,
            (),
            |_, rule, target| {
                let module = match rule {
                    NinjaRule::Binary => {
                        self.generate_object("cc_binary", target, &targets_map, project)?
                    }
                    NinjaRule::SharedLibrary => {
                        self.generate_object("cc_library_shared", target, &targets_map, project)?
                    }
                    NinjaRule::StaticLibrary => {
                        self.generate_object("cc_library_static", target, &targets_map, project)?
                    }
                    NinjaRule::CustomCommand => match target.get_cmd()? {
                        Some(cmd) => self.generate_custom_command(target, cmd, project)?,
                        None => return Ok(()),
                    },
                };
                self.modules.push(module);

                Ok(())
            },
            |target_name| project.filter_target(target_name),
        )
    }
}
