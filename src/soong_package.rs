// Copyright 2024 ninja-to-soong authors
// SPDX-License-Identifier: Apache-2.0

use std::collections::{HashMap, HashSet};

use crate::ninja_target::*;
use crate::project::Project;
use crate::soong_module::*;
use crate::utils::*;

fn update_cflags_with_defines(defines: Vec<String>, project: &dyn Project) -> Vec<String> {
    defines
        .iter()
        .filter(|def| !project.ignore_define(def))
        .map(|def| format!("-D{0}", project.get_define(def)))
        .collect()
}

fn update_cflags(cflags: Vec<String>, project: &dyn Project) -> Vec<String> {
    cflags
        .into_iter()
        .filter(|cflag| !project.ignore_cflag(cflag))
        .collect()
}

fn update_includes(includes: Vec<PathBuf>, project: &dyn Project, src_path: &Path) -> Vec<String> {
    includes
        .into_iter()
        .filter(|include| !project.ignore_include(include))
        .map(|inc| path_to_string(strip_prefix(project.get_include(&inc), src_path)))
        .collect()
}

#[derive(Debug)]
pub struct SoongPackage<'a> {
    modules: Vec<SoongModule>,
    gen_deps: HashSet<PathBuf>,
    generated_libraries: HashSet<PathBuf>,
    src_path: &'a Path,
    ndk_path: &'a Path,
    build_path: &'a Path,
    target_prefix: &'a Path,
}

impl<'a> SoongPackage<'a> {
    pub fn new(
        src_path: &'a Path,
        ndk_path: &'a Path,
        build_path: &'a Path,
        target_prefix: &'a Path,
        default_visibility: &str,
        license_kinds: &str,
        license_text: &str,
    ) -> Self {
        let mut package = Self {
            modules: Vec::new(),
            gen_deps: HashSet::new(),
            generated_libraries: HashSet::new(),
            src_path,
            ndk_path,
            build_path,
            target_prefix,
        };
        let license_name = path_to_id(target_prefix.join(license_text.to_lowercase()));

        let mut package_module = SoongModule::new("package");
        package_module.add_prop(
            "default_visibility",
            SoongProp::VecStr(vec![String::from(default_visibility)]),
        );
        package_module.add_prop(
            "default_applicable_licenses",
            SoongProp::VecStr(vec![license_name.clone()]),
        );
        package.add_module(package_module);

        let mut license_module = SoongModule::new("license");
        license_module.add_prop("name", SoongProp::Str(license_name.clone()));
        license_module.add_prop(
            "visibility",
            SoongProp::VecStr(vec![String::from(":__subpackages__")]),
        );
        license_module.add_prop(
            "license_kinds",
            SoongProp::VecStr(vec![String::from(license_kinds)]),
        );
        license_module.add_prop(
            "license_text",
            SoongProp::VecStr(vec![String::from(license_text)]),
        );
        package.add_module(license_module);

        package
    }

    pub fn get_modules(&mut self) -> &mut Vec<SoongModule> {
        &mut self.modules
    }

    pub fn add_module(&mut self, module: SoongModule) {
        self.modules.push(module);
    }

    pub fn print(self) -> String {
        let mut package = String::from(
            "//
// This file has been auto-generated by ninja-to-soong
//
// ******************************
// *** DO NOT MODIFY MANUALLY ***
// ******************************
//
// https://github.com/rjodinchr/ninja-to-soong
//
",
        );
        for module in self.modules {
            package += &module.print();
        }
        package
    }

    pub fn get_gen_deps(&self) -> HashSet<PathBuf> {
        self.gen_deps.to_owned()
    }

    pub fn get_generated_libraries(&self) -> HashSet<PathBuf> {
        self.generated_libraries.to_owned()
    }

    fn generate_object<T>(
        &mut self,
        name: &str,
        target: &T,
        targets_map: &NinjaTargetsMap<T>,
        project: &dyn Project,
    ) -> Result<SoongModule, String>
    where
        T: NinjaTarget,
    {
        let target_name = target.get_name(self.target_prefix);
        let mut cflags: HashSet<String> =
            HashSet::from_iter(project.get_default_cflags(&target_name));
        let mut includes = HashSet::new();
        let mut srcs = HashSet::new();
        let mut static_libs = HashSet::new();
        let mut shared_libs = HashSet::new();
        let mut gen_deps = Vec::new();
        for input in target.get_inputs() {
            let Some(target) = targets_map.get(input) else {
                return error!("unsupported input for library: {input:#?}");
            };

            let sources = target.get_sources(self.build_path)?;
            for source in sources {
                if project.ignore_source(&source) {
                    continue;
                }
                if source.starts_with(self.build_path) {
                    gen_deps.push(strip_prefix(&source, self.build_path));
                }
                srcs.insert(path_to_string(strip_prefix(
                    project.get_source(&source),
                    self.src_path,
                )));
            }

            let (static_libraries, shared_libraries) = target.get_link_libraries()?;
            static_libs.extend(static_libraries);
            shared_libs.extend(shared_libraries);

            includes.extend(update_includes(
                target.get_includes(self.build_path),
                project,
                self.src_path,
            ));
            cflags.extend(update_cflags_with_defines(target.get_defines(), project));
            cflags.extend(update_cflags(target.get_cflags(), project));
        }

        includes.extend(update_includes(
            target.get_includes(self.build_path),
            project,
            self.src_path,
        ));
        cflags.extend(update_cflags_with_defines(target.get_defines(), project));
        cflags.extend(update_cflags(target.get_cflags(), project));

        let (version_script, link_flags) = target.get_link_flags();
        let link_flags = link_flags
            .into_iter()
            .filter(|flag| !project.ignore_link_flag(flag))
            .collect::<Vec<String>>();
        let (static_libraries, shared_libraries) = target.get_link_libraries()?;
        static_libs.extend(static_libraries);
        shared_libs.extend(shared_libraries);

        let mut static_libs = static_libs
            .into_iter()
            .fold(HashSet::new(), |mut set, lib| {
                let library = path_to_string(&lib);
                if project.ignore_lib(&library) {
                    return set;
                }
                set.insert(if lib.starts_with(self.ndk_path) {
                    file_stem(&lib)
                } else {
                    self.generated_libraries.insert(lib.clone());
                    let lib_id = path_to_id(project.get_library_name(&lib));
                    project.get_target_alias(&lib_id).unwrap_or(lib_id)
                });
                set
            });
        static_libs.extend(project.get_static_libs(&target_name));
        let mut shared_libs = shared_libs
            .into_iter()
            .fold(HashSet::new(), |mut set, lib| {
                let library = path_to_string(&lib);
                if project.ignore_lib(&library) {
                    return set;
                }
                set.insert(if lib.starts_with(self.ndk_path) {
                    file_stem(&lib)
                } else {
                    self.generated_libraries.insert(lib.clone());
                    let lib_id = path_to_id(project.get_library_name(&lib));
                    project.get_target_alias(&lib_id).unwrap_or(lib_id)
                });
                set
            });
        shared_libs.extend(project.get_shared_libs(&target_name));

        let headers = targets_map.traverse_from(
            target.get_outputs().clone(),
            HashSet::new(),
            |gen_headers, rule, target| match rule {
                NinjaRule::CustomCommand => {
                    if target.get_cmd()?.is_none() {
                        return Ok(());
                    }
                    gen_headers.extend(target.get_outputs().clone());
                    return Ok(());
                }
                _ => return Ok(()),
            },
            |_target_name| false,
        )?;

        let mut gen_headers = HashSet::new();
        for header in headers {
            if project.ignore_gen_header(&header) {
                gen_deps.push(header.clone());
            } else {
                gen_headers.insert(match targets_map.get(&header) {
                    Some(target_header) => target_header.get_name(self.target_prefix),
                    None => return error!("Could not find target for {name:#?}"),
                });
            }
        }
        self.gen_deps.extend(gen_deps);

        let module_name = if let Some(alias) = project.get_target_alias(&target_name) {
            alias
        } else {
            target_name.clone()
        };
        static_libs.remove(&module_name);
        shared_libs.remove(&module_name);

        let mut module = SoongModule::new(name);
        module.add_prop("name", SoongProp::Str(module_name));
        if let Some(vs) = version_script {
            module.add_prop(
                "version_script",
                SoongProp::Str(path_to_string(strip_prefix(vs, &self.src_path))),
            );
        }
        module.add_prop("srcs", SoongProp::VecStr(Vec::from_iter(srcs)));
        module.add_prop("cflags", SoongProp::VecStr(Vec::from_iter(cflags)));
        module.add_prop("ldflags", SoongProp::VecStr(link_flags));
        module.add_prop(
            "shared_libs",
            SoongProp::VecStr(Vec::from_iter(shared_libs)),
        );
        module.add_prop(
            "static_libs",
            SoongProp::VecStr(Vec::from_iter(static_libs)),
        );
        module.add_prop(
            "local_include_dirs",
            SoongProp::VecStr(Vec::from_iter(includes)),
        );
        module.add_prop(
            "header_libs",
            SoongProp::VecStr(project.get_target_header_libs(&target_name)),
        );
        module.add_prop(
            "generated_headers",
            SoongProp::VecStr(Vec::from_iter(gen_headers)),
        );
        module.add_prop("use_clang_lld", SoongProp::Bool(true));

        project.get_library_module(&mut module);

        Ok(module)
    }

    fn rework_cmd(
        &self,
        rule_cmd: NinjaRuleCmd,
        inputs: HashSet<PathBuf>,
        outputs: &Vec<PathBuf>,
        deps: HashMap<PathBuf, String>,
        project: &dyn Project,
    ) -> String {
        let mut cmd = rule_cmd.0;
        while let Some(index) = cmd.find("python") {
            let begin = std::str::from_utf8(&cmd.as_bytes()[0..index])
                .unwrap()
                .rfind(" ")
                .unwrap_or_default();
            cmd = match std::str::from_utf8(&cmd.as_bytes()[index..])
                .unwrap()
                .find(" ")
            {
                Some(end) => cmd.replace(
                    std::str::from_utf8(&cmd.as_bytes()[begin..index + end + 1]).unwrap(),
                    "",
                ),
                None => cmd.replace(std::str::from_utf8(&cmd.as_bytes()[begin..]).unwrap(), ""),
            };
        }
        cmd = cmd.replace(
            &format!(
                "{0}{1}",
                path_to_string(self.build_path),
                std::path::MAIN_SEPARATOR
            ),
            "",
        );
        for output in outputs {
            let marker = "<output>";
            let space_and_marker = String::from(" ") + marker;
            let space_and_last_output = String::from(" ") + &file_name(output);
            cmd = cmd.replace(&path_to_string(output), marker);
            cmd = cmd.replace(&space_and_last_output, &space_and_marker);
            let replace_output =
                String::from("$(location ") + &path_to_string(project.get_cmd_output(output)) + ")";
            cmd = cmd.replace(marker, &replace_output)
        }
        for input in inputs {
            let replace_input = String::from("$(location ")
                + &path_to_string(strip_prefix(
                    canonicalize_path(&input, self.build_path),
                    self.src_path,
                ))
                + ")";
            cmd = cmd.replace(&path_to_string(&input), &replace_input)
        }
        for (dep, dep_target_name) in deps {
            let replace_dep = String::from("$(location :") + &dep_target_name + ")";
            cmd = cmd.replace(&path_to_string(&dep), &replace_dep)
        }
        if let Some((rsp_file, rsp_content)) = rule_cmd.1 {
            let rsp = format!("$(genDir)/{rsp_file}");
            let rsp_files = rsp_content
                .split(" ")
                .filter(|file| !file.is_empty())
                .map(|file| {
                    String::from("$(location ")
                        + &path_to_string(strip_prefix(
                            canonicalize_path(file, self.build_path),
                            self.src_path,
                        ))
                        + ")"
                })
                .collect::<Vec<String>>();
            cmd = format!("echo \\\"{0}\\\" > {rsp} && {cmd}", rsp_files.join(" "));
            cmd = cmd.replace("${rspfile}", &rsp);
        }
        cmd
    }

    fn generate_custom_command<T>(
        &mut self,
        target: &T,
        rule_cmd: NinjaRuleCmd,
        project: &dyn Project,
    ) -> Result<SoongModule, String>
    where
        T: NinjaTarget,
    {
        let mut inputs = HashSet::new();
        let mut deps = HashMap::new();
        let mut all_inputs = target.get_inputs().clone();
        all_inputs.extend(target.get_implicit_deps().clone());
        'target_inputs: for input in all_inputs {
            if project.ignore_custom_cmd_input(&input) {
                continue;
            }
            for (prefix, dep) in project.get_deps_info() {
                if input.starts_with(&prefix) {
                    deps.insert(
                        input.clone(),
                        dep_name(&input, &prefix, dep.str(), self.build_path),
                    );
                    continue 'target_inputs;
                }
            }
            if !canonicalize_path(&input, self.build_path).starts_with(self.src_path) {
                deps.insert(
                    input.clone(),
                    dep_name(
                        &input,
                        self.build_path,
                        project.get_id().str(),
                        self.build_path,
                    ),
                );
            } else {
                inputs.insert(input);
            }
        }
        let mut srcs_set = HashSet::new();
        for input in &inputs {
            srcs_set.insert(path_to_string(strip_prefix(
                canonicalize_path(input, self.build_path),
                self.src_path,
            )));
        }
        for (dep, dep_target_name) in &deps {
            srcs_set.insert(String::from(":") + dep_target_name);
            self.gen_deps.insert(dep.clone());
        }
        let target_outputs = target.get_outputs();
        let mut out_set = HashSet::new();
        for output in target_outputs {
            out_set.insert(path_to_string(project.get_cmd_output(output)));
        }
        let cmd = self.rework_cmd(rule_cmd, inputs, target_outputs, deps, project);

        let mut module = SoongModule::new("cc_genrule");
        module.add_prop("name", SoongProp::Str(target.get_name(self.target_prefix)));
        module.add_prop("cmd", SoongProp::Str(cmd));
        module.add_prop("srcs", SoongProp::VecStr(Vec::from_iter(srcs_set)));
        module.add_prop("out", SoongProp::VecStr(Vec::from_iter(out_set)));

        Ok(module)
    }

    pub fn generate<T>(
        &mut self,
        targets_to_generate: Vec<PathBuf>,
        targets: Vec<T>,
        project: &dyn Project,
    ) -> Result<(), String>
    where
        T: NinjaTarget,
    {
        let targets_map = NinjaTargetsMap::new(&targets);
        targets_map.traverse_from(
            targets_to_generate,
            (),
            |_, rule, target| {
                let module = match rule {
                    NinjaRule::Binary => {
                        self.generate_object("cc_binary", target, &targets_map, project)?
                    }
                    NinjaRule::SharedLibrary => {
                        self.generate_object("cc_library_shared", target, &targets_map, project)?
                    }
                    NinjaRule::StaticLibrary => {
                        self.generate_object("cc_library_static", target, &targets_map, project)?
                    }
                    NinjaRule::CustomCommand => match target.get_cmd()? {
                        Some(cmd) => self.generate_custom_command(target, cmd, project)?,
                        None => return Ok(()),
                    },
                };
                self.modules.push(module);

                Ok(())
            },
            |target_name| project.ignore_target(target_name),
        )
    }
}
