// Copyright 2024 ninja-to-soong authors
// SPDX-License-Identifier: Apache-2.0;

use crate::ninja_target::*;
use crate::project::*;
use crate::soong_module::*;
use crate::soong_module_generator::*;
use crate::utils::*;

pub struct SoongPackage {
    modules: Vec<SoongModule>,
    generated: Generated,
}

impl SoongPackage {
    pub fn new(
        default_visibility: &str,
        license_module_name: &str,
        license_kinds: Vec<&str>,
        license_text: Vec<&str>,
    ) -> Self {
        let mut package = Self {
            modules: Vec::new(),
            generated: Generated::default(),
        };
        let mut package_module = SoongModule::new("package");
        package_module.add_prop(
            "default_visibility",
            SoongProp::VecStr(vec![String::from(default_visibility)]),
        );
        package_module.add_prop(
            "default_applicable_licenses",
            SoongProp::VecStr(vec![String::from(license_module_name)]),
        );
        package.add_module(package_module);

        let mut license_module = SoongModule::new("license");
        license_module.add_prop("name", SoongProp::Str(String::from(license_module_name)));
        license_module.add_prop(
            "visibility",
            SoongProp::VecStr(vec![String::from(":__subpackages__")]),
        );
        license_module.add_prop(
            "license_kinds",
            SoongProp::VecStr(
                license_kinds
                    .into_iter()
                    .map(|kind| String::from(kind))
                    .collect(),
            ),
        );
        license_module.add_prop(
            "license_text",
            SoongProp::VecStr(
                license_text
                    .into_iter()
                    .map(|text| String::from(text))
                    .collect(),
            ),
        );
        package.add_module(license_module);

        package
    }

    pub fn add_module(&mut self, module: SoongModule) {
        self.modules.push(module);
    }

    pub fn filter_local_include_dirs(&mut self, prefix: &str, files: &Vec<PathBuf>) {
        let mut set = std::collections::HashSet::new();
        for file in files {
            let mut path = file.clone();
            while let Some(parent) = path.parent() {
                path = PathBuf::from(parent);
                set.insert(path.clone());
            }
        }
        for module in &mut self.modules {
            module.update_prop("local_include_dirs", |prop| match prop {
                SoongProp::VecStr(dirs) => SoongProp::VecStr(
                    dirs.into_iter()
                        .filter(|dir| {
                            if let Ok(strip) = Path::new(&dir).strip_prefix(prefix) {
                                if !set.contains(strip) {
                                    return false;
                                }
                            }
                            return true;
                        })
                        .collect(),
                ),
                _ => prop,
            });
        }
    }

    pub fn print(self) -> String {
        let mut package = String::from(
            "//
// This file has been auto-generated by ninja-to-soong
//
// ******************************
// *** DO NOT MODIFY MANUALLY ***
// ******************************
//
// https://github.com/rjodinchr/ninja-to-soong
//
",
        );
        for module in self.modules {
            package += &module.print();
        }
        package
    }

    pub fn get_gen_deps(&mut self) -> Vec<PathBuf> {
        self.generated.deps.sort_unstable();
        self.generated.deps.dedup();
        std::mem::take(&mut self.generated.deps)
    }

    pub fn get_gen_libs(&mut self) -> Vec<PathBuf> {
        self.generated.libs.sort_unstable();
        self.generated.libs.dedup();
        std::mem::take(&mut self.generated.libs)
    }

    pub fn generate<T>(
        mut self,
        targets_to_generate: Vec<PathBuf>,
        targets: Vec<T>,
        src_path: &Path,
        ndk_path: &Path,
        build_path: &Path,
        project: &dyn Project,
    ) -> Result<SoongPackage, String>
    where
        T: NinjaTarget,
    {
        let targets_map = NinjaTargetsMap::new(&targets);
        let mut gen =
            SoongModuleGenerator::new(src_path, ndk_path, build_path, &targets_map, project);
        targets_map.traverse_from(
            targets_to_generate,
            (),
            |_, rule, target| {
                let module = match rule {
                    NinjaRule::Binary => gen.generate_object("cc_binary", target)?,
                    NinjaRule::SharedLibrary => gen.generate_object("cc_library_shared", target)?,
                    NinjaRule::StaticLibrary => gen.generate_object("cc_library_static", target)?,
                    NinjaRule::CustomCommand => match target.get_cmd()? {
                        Some(cmd) => gen.generate_custom_command(target, cmd)?,
                        None => return Ok(()),
                    },
                };
                self.modules.push(module);

                Ok(())
            },
            |target_name| {
                debug_project!("filter_target({target_name:#?})");
                project.filter_target(target_name)
            },
        )?;
        self.generated = gen.delete();

        Ok(self)
    }
}
