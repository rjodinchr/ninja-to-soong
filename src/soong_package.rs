// Copyright 2024 ninja-to-soong authors
// SPDX-License-Identifier: Apache-2.0

use std::collections::{HashMap, HashSet};

use crate::ninja_target::*;
use crate::project::Project;
use crate::soong_module::SoongModule;
use crate::utils::*;

fn update_cflags_with_defines(
    defines: Vec<String>,
    project: &dyn Project,
    cflags: &mut HashSet<String>,
) {
    for define in defines {
        if project.ignore_define(&define) {
            continue;
        }
        cflags.insert("-D".to_string() + &define);
    }
}

fn update_cflags(cflags: Vec<String>, project: &dyn Project, all_cflags: &mut HashSet<String>) {
    for cflag in cflags {
        if project.ignore_cflag(&cflag) {
            continue;
        }
        all_cflags.insert(cflag);
    }
}

fn update_includes(
    incs: Vec<PathBuf>,
    project: &dyn Project,
    includes: &mut HashSet<String>,
    src_path: &Path,
) {
    for include in incs {
        if project.ignore_include(&include) {
            continue;
        }
        includes.insert(path_to_string(strip_prefix(
            project.get_include(&include),
            src_path,
        )));
    }
}

#[derive(Debug)]
pub struct SoongPackage<'a> {
    modules: Vec<SoongModule>,
    gen_deps: HashSet<PathBuf>,
    generated_libraries: HashSet<PathBuf>,
    src_path: &'a Path,
    ndk_path: &'a Path,
    build_path: &'a Path,
    target_prefix: &'a Path,
}

impl<'a> SoongPackage<'a> {
    pub fn new(
        src_path: &'a Path,
        ndk_path: &'a Path,
        build_path: &'a Path,
        target_prefix: &'a Path,
        default_visibility: &str,
        license_kinds: &str,
        license_text: &str,
    ) -> Self {
        let mut package = Self {
            modules: Vec::new(),
            gen_deps: HashSet::new(),
            generated_libraries: HashSet::new(),
            src_path,
            ndk_path,
            build_path,
            target_prefix,
        };
        let license_name = path_to_id(target_prefix.join(license_text.to_lowercase()));

        let mut package_module = SoongModule::new("package");
        package_module.add_vec("default_applicable_licenses", [license_name.clone()].into());
        package_module.add_vec(
            "default_visibility",
            [default_visibility.to_string()].into(),
        );
        package.add_module(package_module);

        let mut license_module = SoongModule::new("license");
        license_module.add_str("name", license_name.clone());
        license_module.add_vec("visibility", [":__subpackages__".to_string()].into());
        license_module.add_vec("license_kinds", [license_kinds.to_string()].into());
        license_module.add_vec("license_text", [license_text.to_string()].into());
        package.add_module(license_module);

        package
    }

    pub fn get_modules(&mut self) -> &mut Vec<SoongModule> {
        &mut self.modules
    }

    pub fn add_module(&mut self, module: SoongModule) {
        self.modules.push(module);
    }

    pub fn print(self) -> String {
        let mut package = "//
// This file has been auto-generated by ninja-to-soong
//
// ******************************
// *** DO NOT MODIFY MANUALLY ***
// ******************************
//
// https://github.com/rjodinchr/ninja-to-soong
//
"
        .to_string();
        for module in self.modules {
            package += &module.print();
        }
        package
    }

    pub fn get_gen_deps(&self) -> HashSet<PathBuf> {
        self.gen_deps.to_owned()
    }

    pub fn get_generated_libraries(&self) -> HashSet<PathBuf> {
        self.generated_libraries.to_owned()
    }

    fn generate_library<T>(
        &mut self,
        name: &str,
        target: &T,
        targets_map: &NinjaTargetsMap<T>,
        project: &dyn Project,
    ) -> Result<SoongModule, String>
    where
        T: NinjaTarget,
    {
        let mut cflags: HashSet<String> = HashSet::from_iter(project.get_default_cflags());
        let mut includes = HashSet::new();
        let mut srcs = HashSet::new();
        let mut static_libs = HashSet::new();
        let mut shared_libs = HashSet::new();
        for input in target.get_inputs() {
            let Some(target) = targets_map.get(input) else {
                return error!("unsupported input for library: {input:#?}");
            };

            let sources = target.get_sources(self.build_path)?;
            for source in sources {
                if project.ignore_source(&source) {
                    continue;
                }
                srcs.insert(path_to_string(strip_prefix(
                    project.get_source(&source),
                    self.src_path,
                )));
            }

            let (static_libraries, shared_libraries) = target.get_link_libraries()?;
            static_libs.extend(static_libraries);
            shared_libs.extend(shared_libraries);

            update_includes(
                target.get_includes(self.build_path),
                project,
                &mut includes,
                self.src_path,
            );
            update_cflags_with_defines(target.get_defines(), project, &mut cflags);
            update_cflags(target.get_cflags(), project, &mut cflags);
        }

        update_includes(
            target.get_includes(self.build_path),
            project,
            &mut includes,
            self.src_path,
        );
        update_cflags_with_defines(target.get_defines(), project, &mut cflags);
        update_cflags(target.get_cflags(), project, &mut cflags);

        let (version_script, link_flags) = target.get_link_flags();
        let link_flags = link_flags.into_iter().fold(Vec::new(), |mut vec, flag| {
            if !project.ignore_link_flag(&flag) {
                vec.push(flag)
            }
            vec
        });
        let (static_libraries, shared_libraries) = target.get_link_libraries()?;
        static_libs.extend(static_libraries);
        shared_libs.extend(shared_libraries);

        let target_name = target.get_name(self.target_prefix);

        let mut static_libs = static_libs
            .into_iter()
            .fold(HashSet::new(), |mut vec, lib| {
                let library = path_to_string(&lib);
                if project.ignore_lib(&library) {
                    return vec;
                }
                vec.insert(if lib.starts_with(self.ndk_path) {
                    lib.file_stem().unwrap().to_str().unwrap().to_string()
                } else {
                    self.generated_libraries.insert(lib.clone());
                    let lib_id = path_to_id(project.get_library_name(&lib));
                    project.get_target_alias(&lib_id).unwrap_or(lib_id)
                });
                vec
            });
        static_libs.extend(project.get_static_libs(&target_name));
        let mut shared_libs = shared_libs
            .into_iter()
            .fold(HashSet::new(), |mut vec, lib| {
                let library = path_to_string(&lib);
                if project.ignore_lib(&library) {
                    return vec;
                }
                vec.insert(if lib.starts_with(self.ndk_path) {
                    lib.file_stem().unwrap().to_str().unwrap().to_string()
                } else {
                    self.generated_libraries.insert(lib.clone());
                    let lib_id = path_to_id(project.get_library_name(&lib));
                    project.get_target_alias(&lib_id).unwrap_or(lib_id)
                });
                vec
            });
        shared_libs.extend(project.get_shared_libs(&target_name));

        let headers = targets_map.traverse_from(
            target.get_outputs().clone(),
            HashSet::new(),
            |gen_headers, rule, name, target| {
                if rule.is_none() {
                    return Ok(());
                }
                match rule.unwrap() {
                    NinjaRule::CustomCommand => {
                        if target.get_cmd()?.is_none() {
                            return Ok(());
                        }
                        gen_headers.insert(name.to_path_buf());
                        return Ok(());
                    }
                    _ => return Ok(()),
                }
            },
            |_target_name| false,
        )?;
        let mut gen_headers = Vec::new();
        let mut gen_deps = Vec::new();

        for header in headers {
            if project.ignore_gen_header(&header) {
                gen_deps.push(header);
            } else {
                gen_headers.push(match targets_map.get(&header) {
                    Some(target_header) => target_header.get_name(self.target_prefix),
                    None => return error!("Could not find target for {name:#?}"),
                });
            }
        }
        self.gen_deps.extend(gen_deps);

        let module_name = if let Some(alias) = project.get_target_alias(&target_name) {
            alias
        } else {
            target_name.clone()
        };
        static_libs.remove(&module_name);
        shared_libs.remove(&module_name);

        let mut module = SoongModule::new(name);
        if project.optimize_target_for_size(&target_name) {
            module.add_bool("optimize_for_size", true);
        }
        module.add_bool("use_clang_lld", true);
        module.add_vec("srcs", Vec::from_iter(srcs));
        module.add_vec("local_include_dirs", Vec::from_iter(includes));
        module.add_vec("cflags", Vec::from_iter(cflags));
        module.add_vec("ldflags", link_flags);
        module.add_vec("static_libs", Vec::from_iter(static_libs));
        module.add_vec("shared_libs", Vec::from_iter(shared_libs));
        module.add_vec("header_libs", project.get_target_header_libs(&target_name));
        module.add_vec("generated_headers", gen_headers);
        if let Some(vs) = version_script {
            module.add_str(
                "version_script",
                path_to_string(strip_prefix(vs, &self.src_path)),
            );
        }
        module.add_str("name", module_name);
        Ok(module)
    }

    fn rework_cmd(
        &self,
        rule_cmd: NinjaRuleCmd,
        inputs: HashSet<PathBuf>,
        outputs: &Vec<PathBuf>,
        deps: HashMap<PathBuf, String>,
        project: &dyn Project,
    ) -> String {
        let mut cmd = rule_cmd.0;
        while let Some(index) = cmd.find("python") {
            let begin = std::str::from_utf8(&cmd.as_bytes()[0..index])
                .unwrap()
                .rfind(" ")
                .unwrap_or_default();
            cmd = match std::str::from_utf8(&cmd.as_bytes()[index..])
                .unwrap()
                .find(" ")
            {
                Some(end) => cmd.replace(
                    std::str::from_utf8(&cmd.as_bytes()[begin..index + end + 1]).unwrap(),
                    "",
                ),
                None => cmd.replace(std::str::from_utf8(&cmd.as_bytes()[begin..]).unwrap(), ""),
            };
        }
        let build_path = path_to_string(self.build_path) + &std::path::MAIN_SEPARATOR.to_string();
        cmd = cmd.replace(&(build_path), "");
        for output in outputs {
            let marker = "<output>";
            let space_and_marker = String::from(" ") + marker;
            let space_and_last_output = String::from(" ") + &file_name(output);
            cmd = cmd.replace(&path_to_string(output), marker);
            cmd = cmd.replace(&space_and_last_output, &space_and_marker);
            let replace_output =
                String::from("$(location ") + &path_to_string(project.get_cmd_output(output)) + ")";
            cmd = cmd.replace(marker, &replace_output)
        }
        for input in inputs {
            let replace_input = String::from("$(location ")
                + &path_to_string(strip_prefix(
                    canonicalize_path(&input, self.build_path),
                    self.src_path,
                ))
                + ")";
            cmd = cmd.replace(&path_to_string(&input), &replace_input)
        }
        for (dep, dep_target_name) in deps {
            let replace_dep = String::from("$(location :") + &dep_target_name + ")";
            cmd = cmd.replace(&path_to_string(&dep), &replace_dep)
        }
        if let Some((rsp_file, rsp_content)) = rule_cmd.1 {
            let rsp = "$(genDir)/".to_string() + &rsp_file;
            let mut rsp_files = Vec::new();
            for file in rsp_content.split(" ") {
                if file.is_empty() {
                    continue;
                }
                rsp_files.push(
                    String::from("$(location ")
                        + &path_to_string(strip_prefix(
                            canonicalize_path(file, self.build_path),
                            self.src_path,
                        ))
                        + ")",
                );
            }
            cmd = "echo \\\"".to_string() + &rsp_files.join(" ") + "\\\" > " + &rsp + " && " + &cmd;
            cmd = cmd.replace("${rspfile}", &rsp);
        }
        cmd
    }

    fn generate_custom_command<T>(
        &mut self,
        target: &T,
        rule_cmd: NinjaRuleCmd,
        project: &dyn Project,
    ) -> Result<SoongModule, String>
    where
        T: NinjaTarget,
    {
        let mut inputs = HashSet::new();
        let mut deps = HashMap::new();
        let mut all_inputs = target.get_inputs().clone();
        all_inputs.extend(target.get_implicit_deps().clone());
        'target_inputs: for input in all_inputs {
            if project.ignore_custom_cmd_input(&input) {
                continue;
            }
            for (prefix, dep) in project.get_deps_info() {
                if input.starts_with(&prefix) {
                    deps.insert(
                        input.clone(),
                        dep_name(&input, &prefix, dep.str(), self.build_path),
                    );
                    continue 'target_inputs;
                }
            }
            if !canonicalize_path(&input, self.build_path).starts_with(self.src_path) {
                deps.insert(
                    input.clone(),
                    dep_name(
                        &input,
                        self.build_path,
                        project.get_id().str(),
                        self.build_path,
                    ),
                );
            } else {
                inputs.insert(input);
            }
        }
        let mut srcs_set: HashSet<String> = HashSet::new();
        for input in &inputs {
            srcs_set.insert(path_to_string(strip_prefix(
                canonicalize_path(input, self.build_path),
                self.src_path,
            )));
        }
        for (dep, dep_target_name) in &deps {
            srcs_set.insert(String::from(":") + dep_target_name);
            self.gen_deps.insert(dep.clone());
        }
        let target_outputs = target.get_outputs();
        let mut out_set: HashSet<String> = HashSet::new();
        for output in target_outputs {
            out_set.insert(path_to_string(project.get_cmd_output(output)));
        }
        let cmd = self.rework_cmd(rule_cmd, inputs, target_outputs, deps, project);

        let mut module = SoongModule::new("cc_genrule");
        module.add_str("name", target.get_name(self.target_prefix));
        module.add_vec("srcs", Vec::from_iter(srcs_set));
        module.add_vec("out", Vec::from_iter(out_set));
        module.add_str("cmd", cmd.to_string());
        Ok(module)
    }

    pub fn generate<T>(
        &mut self,
        targets_to_generate: Vec<PathBuf>,
        targets: Vec<T>,
        project: &dyn Project,
    ) -> Result<(), String>
    where
        T: NinjaTarget,
    {
        let targets_map = NinjaTargetsMap::new(&targets);
        targets_map.traverse_from(
            targets_to_generate,
            (),
            |_, rule, _name, target| {
                let Some(ninja_rule) = rule else {
                    return Ok(());
                };
                let module = match ninja_rule {
                    NinjaRule::SharedLibrary => {
                        self.generate_library("cc_library_shared", target, &targets_map, project)?
                    }
                    NinjaRule::StaticLibrary => {
                        self.generate_library("cc_library_static", target, &targets_map, project)?
                    }
                    NinjaRule::CustomCommand => match target.get_cmd()? {
                        Some(cmd) => self.generate_custom_command(target, cmd, project)?,
                        None => return Ok(()),
                    },
                };
                self.modules.push(module);

                Ok(())
            },
            |target_name| project.ignore_target(target_name),
        )
    }
}
