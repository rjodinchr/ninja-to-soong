// Copyright 2024 ninja-to-soong authors
// SPDX-License-Identifier: Apache-2.0

use std::collections::HashSet;

use crate::ninja_target::{NinjaTarget, NinjaTargetsMap};
use crate::project::Project;
use crate::soong_module::SoongModule;
use crate::utils::*;

#[derive(Debug)]
pub struct SoongPackage<'a> {
    modules: Vec<SoongModule>,
    gen_deps: HashSet<PathBuf>,
    generated_libraries: HashSet<PathBuf>,
    src_path: &'a Path,
    ndk_path: &'a Path,
    build_path: &'a Path,
    target_prefix: &'a Path,
}

impl<'a> SoongPackage<'a> {
    pub fn new(
        src_path: &'a Path,
        ndk_path: &'a Path,
        build_path: &'a Path,
        target_prefix: &'a Path,
        default_visibility: &str,
        license_kinds: &str,
        license_text: &str,
    ) -> Self {
        let mut package = Self {
            modules: Vec::new(),
            gen_deps: HashSet::new(),
            generated_libraries: HashSet::new(),
            src_path,
            ndk_path,
            build_path,
            target_prefix,
        };
        let license_name = path_to_id(target_prefix.join(license_text.to_lowercase()));

        let mut package_module = SoongModule::new("package");
        package_module.add_set("default_applicable_licenses", [license_name.clone()].into());
        package_module.add_set(
            "default_visibility",
            [default_visibility.to_string()].into(),
        );
        package.add_module(package_module);

        let mut license_module = SoongModule::new("license");
        license_module.add_str("name", license_name.clone());
        license_module.add_set("visibility", [":__subpackages__".to_string()].into());
        license_module.add_set("license_kinds", [license_kinds.to_string()].into());
        license_module.add_set("license_text", [license_text.to_string()].into());
        package.add_module(license_module);

        package
    }

    pub fn get_modules(&mut self) -> &mut Vec<SoongModule> {
        &mut self.modules
    }

    pub fn add_module(&mut self, module: SoongModule) {
        self.modules.push(module);
    }

    pub fn print(self) -> String {
        let mut package = "//
// This file has been auto-generated by ninja-to-soong
//
// ******************************
// *** DO NOT MODIFY MANUALLY ***
// ******************************
//
// https://github.com/rjodinchr/ninja-to-soong
//
"
        .to_string();
        for module in self.modules {
            package += &module.print();
        }
        package
    }

    pub fn get_gen_deps(&self) -> HashSet<PathBuf> {
        self.gen_deps.to_owned()
    }

    pub fn get_generated_libraries(&self) -> HashSet<PathBuf> {
        self.generated_libraries.to_owned()
    }

    fn generate_library(
        &mut self,
        name: &str,
        target: &NinjaTarget,
        targets_map: &NinjaTargetsMap,
        project: &dyn Project,
    ) -> Result<SoongModule, String> {
        let mut cflags = project.get_default_cflags();
        let mut includes = HashSet::new();
        let mut srcs = HashSet::new();
        for input in target.get_inputs() {
            let Some(target) = targets_map.get(input) else {
                return error!("unsupported input for library: {input:#?}");
            };

            let target_srcs = target.get_inputs();
            if target_srcs.len() != 1 {
                return error!("Too many inputs in target: {self:#?}");
            }
            srcs.insert(path_to_string(strip_prefix(&target_srcs[0], self.src_path)));

            for include in target.get_includes(self.src_path, project) {
                includes.insert(path_to_string(include));
            }
            cflags.extend(target.get_defines(project));
        }

        let (version_script, link_flags) = target.get_link_flags(self.src_path, project);
        let (static_libs, shared_libs, generated_libraries) =
            target.get_link_libraries(self.ndk_path, project)?;
        self.generated_libraries.extend(generated_libraries);
        let (gen_headers, gen_deps) =
            target.get_gen_headers_and_gen_deps(self.target_prefix, targets_map, project)?;
        self.gen_deps.extend(gen_deps);

        let target_name = target.get_name(self.target_prefix);

        let mut module = crate::soong_module::SoongModule::new(name);
        if project.optimize_target_for_size(&target_name) {
            module.add_bool("optimize_for_size", true);
        }
        module.add_bool("use_clang_lld", true);
        module.add_set("srcs", srcs);
        module.add_set("local_include_dirs", includes);
        module.add_set("cflags", cflags);
        module.add_set("ldflags", link_flags);
        module.add_set("static_libs", static_libs);
        module.add_set("shared_libs", shared_libs);
        module.add_set("header_libs", project.get_target_header_libs(&target_name));
        module.add_set("generated_headers", gen_headers);
        if let Some(vs) = version_script {
            module.add_str("version_script", path_to_string(vs));
        }
        if let Some(alias) = project.get_target_alias(&target_name) {
            module.add_str("stem", alias);
        }
        module.add_str("name", target_name);
        Ok(module)
    }

    fn rework_cmd(
        &self,
        mut cmd: String,
        inputs: HashSet<PathBuf>,
        outputs: &Vec<PathBuf>,
        deps: HashSet<(PathBuf, String)>,
        project: &dyn Project,
    ) -> String {
        while let Some(index) = cmd.find("bin/python") {
            let begin = std::str::from_utf8(&cmd.as_bytes()[0..index])
                .unwrap()
                .rfind(" ")
                .unwrap_or_default();
            cmd = match std::str::from_utf8(&cmd.as_bytes()[index..])
                .unwrap()
                .find(" ")
            {
                Some(end) => cmd.replace(
                    std::str::from_utf8(&cmd.as_bytes()[begin..index + end + 1]).unwrap(),
                    "",
                ),
                None => cmd.replace(std::str::from_utf8(&cmd.as_bytes()[begin..]).unwrap(), ""),
            };
        }
        let build_path = path_to_string(self.build_path) + &std::path::MAIN_SEPARATOR.to_string();
        cmd = cmd.replace(&(build_path), "");
        for output in outputs {
            let marker = "<output>";
            let space_and_marker = String::from(" ") + marker;
            let space_and_last_output = String::from(" ") + &file_name(output);
            cmd = cmd.replace(&path_to_string(output), marker);
            cmd = cmd.replace(&space_and_last_output, &space_and_marker);
            let replace_output =
                String::from("$(location ") + &path_to_string(project.get_cmd_output(output)) + ")";
            cmd = cmd.replace(marker, &replace_output)
        }
        for input in inputs {
            let replace_input = String::from("$(location ")
                + &path_to_string(strip_prefix(&input, self.src_path))
                + ")";
            cmd = cmd.replace(&path_to_string(&input), &replace_input)
        }
        for (dep, dep_target_name) in deps {
            let replace_dep = "$(location ".to_string() + &dep_target_name + ")";
            let dep_with_prefix = path_to_string(self.target_prefix.join(&dep));
            cmd = cmd
                .replace(&dep_with_prefix, &replace_dep)
                .replace(&path_to_string(&dep), &replace_dep)
        }
        cmd
    }

    fn generate_custom_command(
        &mut self,
        target: &NinjaTarget,
        mut cmd: String,
        project: &dyn Project,
    ) -> Result<SoongModule, String> {
        let (inputs, deps) = project.get_cmd_inputs_and_deps(target.get_inputs())?;
        let mut srcs_set: HashSet<String> = HashSet::new();
        for input in &inputs {
            srcs_set.insert(path_to_string(strip_prefix(input, self.src_path)));
        }
        for (dep, dep_target_name) in &deps {
            srcs_set.insert(dep_target_name.clone());
            self.gen_deps.insert(dep.clone());
        }
        let target_outputs = target.get_outputs();
        let mut out_set: HashSet<String> = HashSet::new();
        for output in target_outputs {
            out_set.insert(path_to_string(project.get_cmd_output(output)));
        }

        cmd = self.rework_cmd(cmd, inputs, target_outputs, deps, project);

        let mut module = crate::soong_module::SoongModule::new("cc_genrule");
        module.add_str("name", target.get_name(self.target_prefix));
        module.add_set("srcs", srcs_set);
        module.add_set("out", out_set);
        module.add_str("cmd", cmd.to_string());
        Ok(module)
    }

    fn generate_module(
        &mut self,
        rule: &str,
        target: &NinjaTarget,
        targets_map: &NinjaTargetsMap,
        project: &dyn Project,
    ) -> Result<Option<SoongModule>, String> {
        Ok(Some(if rule.starts_with("CXX_SHARED_LIBRARY") {
            self.generate_library("cc_library_shared", target, targets_map, project)
        } else if rule.starts_with("CXX_STATIC_LIBRARY") {
            self.generate_library("cc_library_static", target, targets_map, project)
        } else if rule.starts_with("CUSTOM_COMMAND") {
            match target.get_cmd()? {
                Some(cmd) => self.generate_custom_command(target, cmd, project),
                None => return Ok(None),
            }
        } else if rule.starts_with("CXX_COMPILER")
            || rule.starts_with("C_COMPILER")
            || rule.starts_with("ASM_COMPILER")
            || rule == "phony"
        {
            return Ok(None);
        } else {
            error!("unsupported rule ({rule}) for target: {target:#?}")
        }?))
    }

    pub fn generate(
        &mut self,
        targets_to_generate: Vec<PathBuf>,
        targets: Vec<NinjaTarget>,
        project: &dyn Project,
    ) -> Result<(), String> {
        let targets_map = NinjaTargetsMap::new(&targets);
        targets_map.traverse_from(
            targets_to_generate,
            (),
            |_, rule, _name, target| {
                if let Some(module) = self.generate_module(rule, target, &targets_map, project)? {
                    self.modules.push(module);
                }
                Ok(())
            },
            |target_name| project.ignore_target(target_name),
        )
    }
}
