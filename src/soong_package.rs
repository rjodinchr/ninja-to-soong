// Copyright 2024 ninja-to-soong authors
// SPDX-License-Identifier: Apache-2.0

use std::collections::{HashMap, HashSet};

use crate::ninja_target::*;
use crate::project::Project;
use crate::soong_module::SoongModule;
use crate::utils::*;

#[derive(Debug)]
pub struct SoongPackage<'a> {
    package: String,
    gen_deps: HashSet<String>,
    include_dirs: HashSet<String>,
    generated_libraries: HashSet<String>,
    src_dir: &'a str,
    ndk_dir: &'a str,
    build_dir: &'a str,
    target_prefix: &'a str,
}

impl<'a> SoongPackage<'a> {
    pub fn new(
        src_dir: &'a str,
        ndk_dir: &'a str,
        build_dir: &'a str,
        target_prefix: &'a str,
        default_visibility: &str,
        license_kinds: &str,
        license_text: &str,
    ) -> Self {
        let mut package = SoongPackage {
            package: String::new(),
            gen_deps: HashSet::new(),
            include_dirs: HashSet::new(),
            generated_libraries: HashSet::new(),
            src_dir,
            ndk_dir,
            build_dir,
            target_prefix,
        };
        package.package += "//
// This file has been auto-generated by ninja-to-soong
//
// ******************************
// *** DO NOT MODIFY MANUALLY ***
// ******************************
//
// https://github.com/rjodinchr/ninja-to-soong
//

";
        let license_name =
            target_prefix.to_string() + "_" + &license_text.replace(".", "_").to_lowercase();

        let mut package_module = SoongModule::new("package");
        package_module.add_set("default_applicable_licenses", [license_name.clone()].into());
        package_module.add_set(
            "default_visibility",
            [default_visibility.to_string()].into(),
        );
        package.add_module(package_module);

        let mut license_module = SoongModule::new("license");
        license_module.add_str("name", license_name.clone());
        license_module.add_set("visibility", [":__subpackages__".to_string()].into());
        license_module.add_set("license_kinds", [license_kinds.to_string()].into());
        license_module.add_set("license_text", [license_text.to_string()].into());
        package.add_module(license_module);

        package
    }

    pub fn add_module(&mut self, module: SoongModule) {
        self.package += &module.print();
    }

    pub fn write(self, project_repo_name: &str) -> Result<(), String> {
        const ANDROID_BP: &str = "/Android.bp";
        write_file(&(self.src_dir.to_string() + ANDROID_BP), &self.package)?;
        let tests_path = get_tests_folder()?;
        copy_file(
            &(self.src_dir.to_string() + ANDROID_BP),
            &(add_slash_suffix(&tests_path) + project_repo_name + ANDROID_BP),
            true,
        )?;
        Ok(())
    }

    pub fn get_gen_deps(&self) -> HashSet<String> {
        self.gen_deps.to_owned()
    }

    pub fn get_include_dirs(&self) -> HashSet<String> {
        self.include_dirs.to_owned()
    }

    pub fn get_generated_libraries(&self) -> HashSet<String> {
        self.generated_libraries.to_owned()
    }

    fn generate_library(
        &mut self,
        name: &str,
        target: &NinjaTarget,
        targets_map: &NinjaTargetsMap,
        project: &dyn Project,
    ) -> Result<String, String> {
        let mut cflags = project.get_default_cflags();
        let mut includes: HashSet<String> = HashSet::new();
        let mut srcs: HashSet<String> = HashSet::new();
        for input in target.get_inputs() {
            let Some(target) = targets_map.get(input) else {
                return error!(format!("unsupported input for library: {input}"));
            };

            let target_srcs = target.get_inputs();
            if target_srcs.len() != 1 {
                return error!(format!("Too many inputs in target: {self:#?}"));
            }
            srcs.insert(target_srcs[0].replace(&add_slash_suffix(self.src_dir), ""));

            for inc in target.get_includes(self.src_dir, project) {
                includes.insert(inc.clone());
                self.include_dirs.insert(inc);
            }

            for define in target.get_defines(project) {
                cflags.insert(String::from("-D") + &define);
            }
        }

        let (version_script, link_flags) = target.get_link_flags(self.src_dir, project);
        let (static_libs, shared_libs, generated_libraries) =
            target.get_link_libraries(self.ndk_dir, project)?;
        self.generated_libraries.extend(generated_libraries);
        let (gen_headers, gen_deps) =
            target.get_gen_headers_and_gen_deps(self.target_prefix, targets_map, project)?;
        self.gen_deps.extend(gen_deps);

        let target_name = target.get_name(self.target_prefix);

        let mut module = crate::soong_module::SoongModule::new(name);
        if project.optimize_target_for_size(&target_name) {
            module.add_bool("optimize_for_size", true);
        }
        module.add_bool("use_clang_lld", true);
        module.add_set("srcs", srcs);
        module.add_set("local_include_dirs", includes);
        module.add_set("cflags", cflags);
        module.add_set("ldflags", link_flags);
        module.add_set("static_libs", static_libs);
        module.add_set("shared_libs", shared_libs);
        module.add_set("header_libs", project.get_target_header_libs(&target_name));
        module.add_set("generated_headers", gen_headers);
        module.add_str("version_script", version_script);
        module.add_str("stem", project.get_target_alias(&target_name));
        module.add_str("name", target_name);
        Ok(module.print())
    }

    fn replace_output_in_cmd(
        &self,
        mut cmd: String,
        output: &str,
        project: &dyn Project,
    ) -> String {
        let marker = "<output>";
        let space_and_marker = String::from(" ") + marker;
        let space_and_last_output = String::from(" ") + output.split("/").last().unwrap();
        cmd = cmd.replace(output, marker);
        cmd = cmd.replace(&space_and_last_output, &space_and_marker);
        let replace_output = String::from("$(location ") + &project.get_cmd_output(output) + ")";
        cmd.replace(marker, &replace_output)
    }

    fn replace_input_in_cmd(&self, cmd: String, input: String) -> String {
        let replace_input =
            String::from("$(location ") + &input.replace(&add_slash_suffix(self.src_dir), "") + ")";
        cmd.replace(&input, &replace_input)
    }

    fn replace_dep_in_cmd(
        &self,
        cmd: String,
        dep: String,
        dep_target_name: String,
        prefix: &str,
    ) -> String {
        let replace_dep = "$(location ".to_string() + &dep_target_name + ")";
        let dep_with_prefix = String::from(prefix) + &dep;
        cmd.replace(&dep_with_prefix, &replace_dep)
            .replace(&dep, &replace_dep)
    }

    fn remove_python_in_cmd(mut cmd: String) -> String {
        while let Some(index) = cmd.find("bin/python") {
            let begin = std::str::from_utf8(&cmd.as_bytes()[0..index])
                .unwrap()
                .rfind(" ")
                .unwrap_or_default();
            cmd = match std::str::from_utf8(&cmd.as_bytes()[index..])
                .unwrap()
                .find(" ")
            {
                Some(end) => cmd.replace(
                    std::str::from_utf8(&cmd.as_bytes()[begin..index + end + 1]).unwrap(),
                    "",
                ),
                None => cmd.replace(std::str::from_utf8(&cmd.as_bytes()[begin..]).unwrap(), ""),
            };
        }
        cmd
    }

    fn rework_cmd(
        &self,
        mut cmd: String,
        inputs: HashSet<String>,
        outputs: &Vec<String>,
        deps: HashSet<(String, String)>,
        project: &dyn Project,
    ) -> String {
        cmd = Self::remove_python_in_cmd(cmd);
        cmd = cmd.replace(&add_slash_suffix(self.build_dir), "");
        for output in outputs {
            cmd = self.replace_output_in_cmd(cmd, output, project);
        }
        for input in inputs.clone() {
            cmd = self.replace_input_in_cmd(cmd, input);
        }
        for (dep, dep_target_name) in deps {
            cmd = self.replace_dep_in_cmd(cmd, dep, dep_target_name, self.target_prefix);
        }
        cmd
    }

    fn generate_custom_command(
        &mut self,
        target: &NinjaTarget,
        mut cmd: String,
        project: &dyn Project,
    ) -> Result<String, String> {
        let (inputs, deps) = project.get_cmd_inputs_and_deps(target.get_inputs())?;
        let mut srcs_set: HashSet<String> = HashSet::new();
        for input in &inputs {
            srcs_set.insert(input.replace(&add_slash_suffix(self.src_dir), ""));
        }
        for (dep, dep_target_name) in &deps {
            srcs_set.insert(dep_target_name.clone());
            self.gen_deps.insert(dep.clone());
        }
        let target_outputs = target.get_outputs();
        let out_set = target_outputs
            .into_iter()
            .fold(HashSet::new(), |mut set, output| {
                set.insert(project.get_cmd_output(output));
                set
            });

        cmd = self.rework_cmd(cmd, inputs, target_outputs, deps, project);

        let mut module = crate::soong_module::SoongModule::new("cc_genrule");
        module.add_str("name", target.get_name(self.target_prefix));
        module.add_set("srcs", srcs_set);
        module.add_set("out", out_set);
        module.add_str("cmd", cmd.to_string());
        Ok(module.print())
    }

    fn generate_module(
        &mut self,
        target: &NinjaTarget,
        targets_map: &NinjaTargetsMap,
        project: &dyn Project,
    ) -> Result<Option<String>, String> {
        let rule = target.get_rule();
        Ok(Some(if rule.starts_with("CXX_SHARED_LIBRARY") {
            self.generate_library("cc_library_shared", target, targets_map, project)
        } else if rule.starts_with("CXX_STATIC_LIBRARY") {
            self.generate_library("cc_library_static", target, targets_map, project)
        } else if rule.starts_with("CUSTOM_COMMAND") {
            match target.get_cmd()? {
                Some(cmd) => self.generate_custom_command(target, cmd, project),
                None => return Ok(None),
            }
        } else if rule.starts_with("CXX_COMPILER")
            || rule.starts_with("C_COMPILER")
            || rule.starts_with("ASM_COMPILER")
            || rule == "phony"
        {
            return Ok(None);
        } else {
            error!(format!("unsupported rule ({rule}) for target: {target:#?}"))
        }?))
    }

    pub fn generate(
        &mut self,
        mut targets_to_generate: Vec<String>,
        targets: Vec<NinjaTarget>,
        project: &dyn Project,
    ) -> Result<(), String> {
        let mut targets_seen: HashSet<String> = HashSet::new();
        let mut targets_map: NinjaTargetsMap = HashMap::new();
        for target in &targets {
            for output in &target.get_all_outputs() {
                targets_map.insert(output.clone(), target);
            }
        }

        while let Some(input) = targets_to_generate.pop() {
            if targets_seen.contains(&input) || project.ignore_target(&input) {
                continue;
            }
            let Some(target) = targets_map.get(&input) else {
                continue;
            };

            targets_to_generate.append(&mut target.get_all_inputs());
            for output in target.get_all_outputs() {
                targets_seen.insert(output);
            }

            if let Some(module) = self.generate_module(target, &targets_map, project)? {
                self.package += &module;
            }
        }
        Ok(())
    }
}
